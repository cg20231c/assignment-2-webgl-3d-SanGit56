<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8">
    <title>5025211166</title>
    <style>
        canvas {
            width: 100%;
            height: 100%
        }

        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <canvas id="webglCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>

    <script>
        let canvas = document.getElementById('webglCanvas');
        let gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL is not supported by this browser.');
        }

        function resizer()
        {
            canvas.width = window.innerWidth - 20;
            canvas.height = window.innerHeight - 20;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }

        window.addEventListener('resize',resizer);

        // Shader sources
        const vertexShaderSource = `
            attribute vec4 aPosition;
            attribute vec4 aColor;
            varying vec4 vColor;
            uniform mat4 uModelViewProjectionMatrix;

            void main() {
                gl_Position = uModelViewProjectionMatrix * aPosition;
                vColor = aColor;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec4 vColor;
            uniform vec3 uAmbientColor;

            void main() {
                // Combine ambient, diffuse, and specular lighting
                vec3 lightColor = uAmbientColor;
                gl_FragColor = vec4(vColor.rgb, vColor.a);
            }
        `;

        // Utility functions
        // Compile and link shaders
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        gl.useProgram(program);

        // Set perspective view
        const projectionMatrix = mat4.create();
        const fieldOfView = Math.PI / 6;
        const aspect = canvas.width / canvas.height;
        const zNear = 0.1;
        const zFar = 100.0;
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        // Set camera position and view
        // Set up the view matrix (camera position and orientation)
        const viewMatrix = mat4.create();
        const cameraPosition = vec3.fromValues(3.0, 1.0, 0.0); // Adjust the camera position
        const targetPosition = vec3.fromValues(0.0, 0.0, 0.0); // Point the camera at the origin
        const upVector = vec3.fromValues(0.0, 1.0, 0.0); // Define the up vector
        mat4.lookAt(viewMatrix, cameraPosition, targetPosition, upVector);

        // Combine the view matrix with the projection matrix
        const viewProjectionMatrix = mat4.create();
        mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);

        // Variables for animation
        const translationSpeed = 0.1;
        let angle = 0.0;
        const angularSpeed = 0.01;

        // Transformation matrix
        let modelMatrix = mat4.create();
        let modelViewProjectionMatrix = mat4.create();

        // Capture the event from the keyboard
        let d = [0.0, 0.0];
        const dUniformLocation = gl.getUniformLocation(program, 'u_d');

        document.addEventListener('keydown', (event) => {
            const key = event.key;
            switch (key) {
                case 'ArrowUp':
                    d[1] -= translationSpeed; // Move forward
                    break;
                case 'ArrowDown':
                    d[1] += translationSpeed; // Move backward
                    break;
                case 'ArrowLeft':
                    d[0] -= translationSpeed; // Move left
                    break;
                case 'ArrowRight':
                    d[0] += translationSpeed; // Move right
                    break;
            }
        });

        // Plane construction
        function drawPlane() {
            // Define plane vertices
            const planeVertices = new Float32Array([
                -1.0, 0.0, -1.0,
                1.0, 0.0, -1.0,
                1.0, 0.0, 1.0,
                -1.0, 0.0, 1.0,
            ]);

            // Define plane colors
            const planeColors = new Float32Array([
                0.588235, 0.0, 0.094118, 1.0,
                0.588235, 0.0, 0.094118, 1.0,
                0.588235, 0.0, 0.094118, 1.0,
                0.588235, 0.0, 0.094118, 1.0,
            ]);

            // Define plane faces
            const planeIndices = new Uint16Array([
                0, 1, 2, 0, 2, 3,
            ]);

            // Create buffers for cube vertices, colors, and faces (indices)
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, planeVertices, gl.STATIC_DRAW);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, planeColors, gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planeIndices, gl.STATIC_DRAW);

            // Specify attribute and uniform locations
            const positionAttributeLocation = gl.getAttribLocation(program, 'aPosition');
            const colorAttributeLocation = gl.getAttribLocation(program, 'aColor');
            const modelViewProjectionMatrixLocation = gl.getUniformLocation(program, 'uModelViewProjectionMatrix');

            mat4.multiply(modelViewProjectionMatrix, viewProjectionMatrix, modelMatrix);

            // Pass the modelViewProjectionMatrix to your shaders as a uniform
            gl.uniformMatrix4fv(modelViewProjectionMatrixLocation, false, modelViewProjectionMatrix);

            // Set up attribute pointers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(colorAttributeLocation);
            gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);

            // Clear canvas
            gl.drawElements(gl.TRIANGLES, planeIndices.length, gl.UNSIGNED_SHORT, 0);
        }

        // 3D letter construction and transformation

        // Lighting and illuminated cube
        const ambientColor = vec3.fromValues(0.2, 0.2, 0.2);  // [0.2, 0.2, 0.2];
        const ambientColorLocation = gl.getUniformLocation(program, "uAmbientColor");// Get the uniform locations for directional light direction and color

        gl.uniform3fv(ambientColorLocation, ambientColor);

        // Main rendering function
        function drawScene() {
            // Clear the canvas
            gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black
            gl.enable(gl.DEPTH_TEST);
            gl.clearDepth(1.0);
            gl.depthFunc(gl.LEQUAL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Draw the plane
            drawPlane();

            // Loop for animations
            requestAnimationFrame(drawScene);
        }

        // Start the rendering loop
        drawScene();

    </script>
</body>

</html>